<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
	//https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
var data={a:1,b:2,c:9,d:4,e:5};
	console.log(data);//{a: 1, b: 2, c: 9, d: 4, e: 5}
	console.log(Object.keys(data));//["a", "b", "c", "d", "e"]
	Object.keys(data).map((key,item)=>{
		console.log(key,data[key]);//key=>属性名    data[key]=>属性值
	});
	["a", "b", "c", "d", "e"].map((key,item)=>{
		console.log(key,item)
	})		
//https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
// Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，
// 所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，
// 这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，
// 应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。
const obj = { a: 1 };
const copy = Object.assign({}, obj);

console.log(copy); // { a: 1 }
let obj1 = { a: 0 , b: { c: 0}}; 
let obj2 = Object.assign({}, obj1); 
console.log(obj2);;
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 
obj1.a = 1; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} 
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 

</script>