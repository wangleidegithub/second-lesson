<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title></title>
	</head>
	<body>
		<ul id="members">
			<li><a href="javascript:;">22222222222</a></li><li><a href="">22222222222</a></li>
			<li><a href="">22222222222</a></li>
		</ul>
	</body>
</html>
<script src="js/jquery-1.8.3.js"></script>
<script type="text/javascript">
	$(function(){
		$( "#members li a" ).bind( "click", function(e) {
			console.log(e.target);//<a href="javascript:;">22222222222</a>
		});
	})
	/*12、jQuery的事件委托方法bind 、live、delegate、on之间有什么区别？
(1)、bind 【jQuery 1.3之前】
定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；

语法：bind(type,[data],function(eventObject))；

特点：

　　(1)、适用于页面元素静态绑定。只能给调用它的时候已经存在的元素绑定事件，不能给未来新增的元素绑定事件。

　　(2)、当页面加载完的时候，你才可以进行bind()，所以可能产生效率问题。

实例如下：$( "#members li a" ).bind( "click", function( e ) {} );

(2)、live 【jQuery 1.3之后】
定义和用法：主要用于给选择到的元素上绑定特定事件类型的监听函数；

语法：live(type, [data], fn);

特点：

　　(1)、live方法并没有将监听器绑定到自己(this)身上，而是绑定到了this.context上了。

　　(2)、live正是利用了事件委托机制来完成事件的监听处理，把节点的处理委托给了document，新添加的元素不必再绑定一次监听器。

　　(3)、使用live（）方法但却只能放在直接选择的元素后面，不能在层级比较深，连缀的DOM遍历方法后面使用，即$(“ul”").live...可以，但$("body").find("ul").live...不行； 

实例如下：$( document ).on( "click", "#members li a", function( e ) {} );

(3)、delegate 【jQuery 1.4.2中引入】
定义和用法：将监听事件绑定在就近的父级元素上

语法：delegate(selector,type,[data],fn)

特点：

　　(1)、选择就近的父级元素，因为事件可以更快的冒泡上去，能够在第一时间进行处理。

　　(2)、更精确的小范围使用事件代理，性能优于.live()。可以用在动态添加的元素上。

实例如下：*/

//$("#info_table").delegate("td","click",function(){显示更多信息});

///*$("table").find("#info").delegate("td","click",function(){/*显示更多信息*/});

//(4)、on 【1.7版本整合了之前的三种方式的新事件绑定机制】
//定义和用法：将监听事件绑定到指定元素上。

//语法：on(type,[selector],[data],fn)

//实例如下：$("#info_table").on("click","td",function(){显示更多信息});参数的位置写法与delegate不一样。

/*说明：on方法是当前JQuery推荐使用的事件绑定方法，附加只运行一次就删除函数的方法是one()。

 总结：.bind(), .live(), .delegate(),.on()分别对应的相反事件为：.unbind(),.die(), .undelegate(),.off()*/*/*/*/
</script>